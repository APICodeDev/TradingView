//@version=5
strategy("Advanced Crypto Strategy - DOGEUSDT", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10, margin_long=100, margin_short=100)

// Input parameters
risk_percent = input.float(2.0, "Minimum Profit Target (%)", minval=0.5, maxval=10.0, step=0.1)
atr_length = input.int(14, "ATR Length", minval=1, maxval=100)
volume_ma_length = input.int(20, "Volume MA Length", minval=1, maxval=100)
lookback_period = input.int(100, "Lookback Period for Liquidity Zones", minval=10, maxval=500)
sensitivity = input.float(0.5, "Liquidity Zone Sensitivity", minval=0.1, maxval=2.0, step=0.1)
volume_threshold = input.float(1.5, "Volume Threshold Multiplier", minval=1.0, maxval=5.0, step=0.1)

// Calculate ATR for volatility
atr = ta.atr(atr_length)

// Calculate volume moving average
vol_ma = ta.sma(volume, volume_ma_length)
volume_signal = volume > vol_ma * volume_threshold  // High volume condition

// Detect liquidity zones (previous highs/lows) - Improved approach
ph = ta.pivothigh(high, lookback_period/2, lookback_period/2)
pl = ta.pivotlow(low, lookback_period/2, lookback_period/2)

// Store multiple pivot levels for better liquidity zone detection
var array<float> resistance_levels = array.new<float>()
var array<float> support_levels = array.new<float>()

// Add new pivot highs to resistance array
if not na(ph)
    array.unshift(resistance_levels, ph)
    // Keep only the 5 most recent levels
    if array.size(resistance_levels) > 5
        array.pop(resistance_levels)

// Add new pivot lows to support array
if not na(pl)
    array.unshift(support_levels, pl)
    // Keep only the 5 most recent levels
    if array.size(support_levels) > 5
        array.pop(support_levels)

// Detect breakouts and breakdowns with multiple levels
bullish_breakout = false
bearish_breakdown = false

// Check for breakouts above resistance levels
if array.size(resistance_levels) > 0
    for i = 0 to array.size(resistance_levels) - 1
        level = array.get(resistance_levels, i)
        if close > level and close[1] <= level
            bullish_breakout := true

// Check for breakdowns below support levels
if array.size(support_levels) > 0
    for i = 0 to array.size(support_levels) - 1
        level = array.get(support_levels, i)
        if close < level and close[1] >= level
            bearish_breakdown := true

// Enhanced trend detection using multiple indicators (for confirmation only)
ema_fast = ta.ema(close, 8)
ema_slow = ta.ema(close, 21)
sma_50 = ta.sma(close, 50)
sma_200 = ta.sma(close, 200)

// Trend based on multiple timeframes
trend_bullish = (ema_fast > ema_slow) and (close > sma_50)  // Short and medium term bullish
trend_bearish = (ema_fast < ema_slow) and (close < sma_50)  // Short and medium term bearish

// Volume Weighted Average Price (VWAP) - important for liquidity
float vwap_value = na
sum_src_vol = 0.0
sum_vol = 0.0
if bar_index > 0
    sum_src_vol := nz(sum_src_vol[1]) + (high + low + close) / 3 * volume
    sum_vol := nz(sum_vol[1]) + volume
    vwap_value := sum_src_vol / sum_vol

// VWAP relationship for trend confirmation
vwap_bullish = not na(vwap_value) and close > vwap_value
vwap_bearish = not na(vwap_value) and close < vwap_value

// Detect potential reversal zones using ATR-based stops
atr_multiplier = sensitivity
bullish_zone = low <= (array.size(support_levels) > 0 ? array.get(support_levels, 0) : low) - (atr * atr_multiplier)
bearish_zone = high >= (array.size(resistance_levels) > 0 ? array.get(resistance_levels, 0) : high) + (atr * atr_multiplier)

// Calculate probability-based targets
profit_target = 1 + (risk_percent / 100)
stop_loss_factor = 1.0  // 1% stop loss (adjustable based on ATR)

// Enhanced entry conditions with multiple confirmations
long_condition = (bullish_breakout or bullish_zone) and (trend_bullish or vwap_bullish) and volume_signal
short_condition = (bearish_breakdown or bearish_zone) and (trend_bearish or vwap_bearish) and volume_signal

// Plot all resistance levels
for i = 0 to array.size(resistance_levels) - 1
    level = array.get(resistance_levels, i)
    plot(level, "Resistance " + str.tostring(i+1), color=color.red, linewidth=1, style=plot.style_dashed)

// Plot all support levels
for i = 0 to array.size(support_levels) - 1
    level = array.get(support_levels, i)
    plot(level, "Support " + str.tostring(i+1), color=color.lime, linewidth=1, style=plot.style_dashed)

// Plot VWAP
plot(vwap_value, "VWAP", color=color.yellow, linewidth=2)

// Plot entry signals
plotshape(long_condition, title="Long Entry", style=shape.labelup, location=location.belowbar, color=color.green, size=size.normal, text="BUY")
plotshape(short_condition, title="Short Entry", style=shape.labeldown, location=location.abovebar, color=color.red, size=size.normal, text="SELL")

// Strategy execution with proper risk management
if long_condition and strategy.position_size == 0
    strategy.entry("Long", strategy.long)
    strategy.exit("Long Exit", "Long", limit=close * profit_target, stop=close * (1 - stop_loss_factor/100))

if short_condition and strategy.position_size == 0
    strategy.entry("Short", strategy.short)
    strategy.exit("Short Exit", "Short", limit=close * (2 - profit_target), stop=close * (1 + stop_loss_factor/100))

// Trailing stop for better profit capture
if strategy.position_size > 0
    strategy.exit("Long Trailing Exit", "Long", limit=close * profit_target, stop=close * (1 - stop_loss_factor/100), trail_price=high * (1 - (atr * 0.5) / high), trail_offset=atr * 0.5)
    
if strategy.position_size < 0
    strategy.exit("Short Trailing Exit", "Short", limit=close * (2 - profit_target), stop=close * (1 + stop_loss_factor/100), trail_price=low * (1 + (atr * 0.5) / low), trail_offset=atr * 0.5)

// Background coloring for trend
bgcolor(trend_bullish ? color.new(color.green, 95) : trend_bearish ? color.new(color.red, 95) : na)

// Performance statistics
var int win_trades = 0
var int loss_trades = 0
var float total_profit = 0.0
var float total_loss = 0.0

if strategy.closedtrades != strategy.closedtrades[1] and strategy.closedtrades > 0
    trade_pl = strategy.closedtrades.pnl(strategy.closedtrades - 1)
    if trade_pl > 0
        win_trades := win_trades + 1
        total_profit := total_profit + trade_pl
    else
        loss_trades := loss_trades + 1
        total_loss := total_loss + math.abs(trade_pl)

// Calculate and display comprehensive statistics
var table stats_table = table.new(position.top_right, 2, 6, bgcolor=color.white, border_width=1)
if barstate.islast
    table.cell(stats_table, 0, 0, "Winning Trades", text_color=color.black)
    table.cell(stats_table, 1, 0, str.tostring(win_trades), text_color=color.black)
    table.cell(stats_table, 0, 1, "Losing Trades", text_color=color.black)
    table.cell(stats_table, 1, 1, str.tostring(loss_trades), text_color=color.black)
    table.cell(stats_table, 0, 2, "Total Trades", text_color=color.black)
    table.cell(stats_table, 1, 2, str.tostring(win_trades + loss_trades), text_color=color.black)
    
    win_rate = win_trades > 0 ? (win_trades / math.max(1, (win_trades + loss_trades))) * 100 : 0
    table.cell(stats_table, 0, 3, "Win Rate", text_color=color.black)
    table.cell(stats_table, 1, 3, str.tostring(win_rate, "#.##") + "%", text_color=color.black)
    
    avg_win = win_trades > 0 ? total_profit / win_trades : 0
    table.cell(stats_table, 0, 4, "Avg Win", text_color=color.black)
    table.cell(stats_table, 1, 4, str.tostring(avg_win, "#.##"), text_color=color.black)
    
    avg_loss = loss_trades > 0 ? total_loss / loss_trades : 0
    table.cell(stats_table, 0, 5, "Avg Loss", text_color=color.black)
    table.cell(stats_table, 1, 5, str.tostring(avg_loss, "#.##"), text_color=color.black)